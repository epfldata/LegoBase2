/* Generated by AutoLifter ? 2014 */

package ch.epfl.data
package legobase
package deep

import scalalib._
import pardis.ir._
import pardis.ir.pardisTypeImplicits._
import pardis.deep.scalalib._

trait GroupByClassOps extends Base { this: DeepDSL =>
  implicit class GroupByClassRep(self: Rep[GroupByClass]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = groupByClassGetField(self, key)
    def L_LINESTATUS: Rep[Character] = groupByClass_Field_L_LINESTATUS(self)
    def L_RETURNFLAG: Rep[Character] = groupByClass_Field_L_RETURNFLAG(self)
  }
  object GroupByClass {

  }
  // constructors
  def __newGroupByClass(L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character]): Rep[GroupByClass] = groupByClassNew(L_RETURNFLAG, L_LINESTATUS)
  // case classes
  case class GroupByClassNew(L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character]) extends ConstructorDef[GroupByClass](List(), "GroupByClass", List(List(L_RETURNFLAG, L_LINESTATUS))) {
    override def curriedConstructor = (copy _).curried
  }

  case class GroupByClassGetField(self: Rep[GroupByClass], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class GroupByClass_Field_L_LINESTATUS(self: Rep[GroupByClass]) extends FieldDef[Character](self, "L_LINESTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class GroupByClass_Field_L_RETURNFLAG(self: Rep[GroupByClass]) extends FieldDef[Character](self, "L_RETURNFLAG") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def groupByClassNew(L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character]): Rep[GroupByClass] = GroupByClassNew(L_RETURNFLAG, L_LINESTATUS)
  def groupByClassGetField(self: Rep[GroupByClass], key: Rep[String]): Rep[Option[Any]] = GroupByClassGetField(self, key)
  def groupByClass_Field_L_LINESTATUS(self: Rep[GroupByClass]): Rep[Character] = GroupByClass_Field_L_LINESTATUS(self)
  def groupByClass_Field_L_RETURNFLAG(self: Rep[GroupByClass]): Rep[Character] = GroupByClass_Field_L_RETURNFLAG(self)
  type GroupByClass = ch.epfl.data.legobase.queryengine.GroupByClass
  case object GroupByClassType extends TypeRep[GroupByClass] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = GroupByClassType
    val name = "GroupByClass"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[GroupByClass]
  }
  implicit val typeGroupByClass = GroupByClassType
}
trait GroupByClassImplicits { this: GroupByClassComponent =>
  // Add implicit conversions here!
}
trait GroupByClassImplementations { self: DeepDSL =>

}
trait GroupByClassComponent extends GroupByClassOps with GroupByClassImplicits { self: DeepDSL => }

trait Q3GRPRecordOps extends Base { this: DeepDSL =>
  implicit class Q3GRPRecordRep(self: Rep[Q3GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q3GRPRecordGetField(self, key)
    def O_SHIPPRIORITY: Rep[Int] = q3GRPRecord_Field_O_SHIPPRIORITY(self)
    def O_ORDERDATE: Rep[Long] = q3GRPRecord_Field_O_ORDERDATE(self)
    def L_ORDERKEY: Rep[Int] = q3GRPRecord_Field_L_ORDERKEY(self)
  }
  object Q3GRPRecord {

  }
  // constructors
  def __newQ3GRPRecord(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_SHIPPRIORITY: Rep[Int]): Rep[Q3GRPRecord] = q3GRPRecordNew(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY)
  // case classes
  case class Q3GRPRecordNew(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_SHIPPRIORITY: Rep[Int]) extends ConstructorDef[Q3GRPRecord](List(), "Q3GRPRecord", List(List(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q3GRPRecordGetField(self: Rep[Q3GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q3GRPRecord_Field_O_SHIPPRIORITY(self: Rep[Q3GRPRecord]) extends FieldDef[Int](self, "O_SHIPPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q3GRPRecord_Field_O_ORDERDATE(self: Rep[Q3GRPRecord]) extends FieldDef[Long](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q3GRPRecord_Field_L_ORDERKEY(self: Rep[Q3GRPRecord]) extends FieldDef[Int](self, "L_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q3GRPRecordNew(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_SHIPPRIORITY: Rep[Int]): Rep[Q3GRPRecord] = Q3GRPRecordNew(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY)
  def q3GRPRecordGetField(self: Rep[Q3GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q3GRPRecordGetField(self, key)
  def q3GRPRecord_Field_O_SHIPPRIORITY(self: Rep[Q3GRPRecord]): Rep[Int] = Q3GRPRecord_Field_O_SHIPPRIORITY(self)
  def q3GRPRecord_Field_O_ORDERDATE(self: Rep[Q3GRPRecord]): Rep[Long] = Q3GRPRecord_Field_O_ORDERDATE(self)
  def q3GRPRecord_Field_L_ORDERKEY(self: Rep[Q3GRPRecord]): Rep[Int] = Q3GRPRecord_Field_L_ORDERKEY(self)
  type Q3GRPRecord = ch.epfl.data.legobase.queryengine.Q3GRPRecord
  case object Q3GRPRecordType extends TypeRep[Q3GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q3GRPRecordType
    val name = "Q3GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q3GRPRecord]
  }
  implicit val typeQ3GRPRecord = Q3GRPRecordType
}
trait Q3GRPRecordImplicits { this: Q3GRPRecordComponent =>
  // Add implicit conversions here!
}
trait Q3GRPRecordImplementations { self: DeepDSL =>

}
trait Q3GRPRecordComponent extends Q3GRPRecordOps with Q3GRPRecordImplicits { self: DeepDSL => }

trait Q7GRPRecordOps extends Base { this: DeepDSL =>
  implicit class Q7GRPRecordRep(self: Rep[Q7GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q7GRPRecordGetField(self, key)
    def L_YEAR: Rep[Long] = q7GRPRecord_Field_L_YEAR(self)
    def CUST_NATION: Rep[OptimalString] = q7GRPRecord_Field_CUST_NATION(self)
    def SUPP_NATION: Rep[OptimalString] = q7GRPRecord_Field_SUPP_NATION(self)
  }
  object Q7GRPRecord {

  }
  // constructors
  def __newQ7GRPRecord(SUPP_NATION: Rep[OptimalString], CUST_NATION: Rep[OptimalString], L_YEAR: Rep[Long]): Rep[Q7GRPRecord] = q7GRPRecordNew(SUPP_NATION, CUST_NATION, L_YEAR)
  // case classes
  case class Q7GRPRecordNew(SUPP_NATION: Rep[OptimalString], CUST_NATION: Rep[OptimalString], L_YEAR: Rep[Long]) extends ConstructorDef[Q7GRPRecord](List(), "Q7GRPRecord", List(List(SUPP_NATION, CUST_NATION, L_YEAR))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q7GRPRecordGetField(self: Rep[Q7GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q7GRPRecord_Field_L_YEAR(self: Rep[Q7GRPRecord]) extends FieldDef[Long](self, "L_YEAR") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q7GRPRecord_Field_CUST_NATION(self: Rep[Q7GRPRecord]) extends FieldDef[OptimalString](self, "CUST_NATION") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q7GRPRecord_Field_SUPP_NATION(self: Rep[Q7GRPRecord]) extends FieldDef[OptimalString](self, "SUPP_NATION") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q7GRPRecordNew(SUPP_NATION: Rep[OptimalString], CUST_NATION: Rep[OptimalString], L_YEAR: Rep[Long]): Rep[Q7GRPRecord] = Q7GRPRecordNew(SUPP_NATION, CUST_NATION, L_YEAR)
  def q7GRPRecordGetField(self: Rep[Q7GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q7GRPRecordGetField(self, key)
  def q7GRPRecord_Field_L_YEAR(self: Rep[Q7GRPRecord]): Rep[Long] = Q7GRPRecord_Field_L_YEAR(self)
  def q7GRPRecord_Field_CUST_NATION(self: Rep[Q7GRPRecord]): Rep[OptimalString] = Q7GRPRecord_Field_CUST_NATION(self)
  def q7GRPRecord_Field_SUPP_NATION(self: Rep[Q7GRPRecord]): Rep[OptimalString] = Q7GRPRecord_Field_SUPP_NATION(self)
  type Q7GRPRecord = ch.epfl.data.legobase.queryengine.Q7GRPRecord
  case object Q7GRPRecordType extends TypeRep[Q7GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q7GRPRecordType
    val name = "Q7GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q7GRPRecord]
  }
  implicit val typeQ7GRPRecord = Q7GRPRecordType
}
trait Q7GRPRecordImplicits { this: Q7GRPRecordComponent =>
  // Add implicit conversions here!
}
trait Q7GRPRecordImplementations { self: DeepDSL =>

}
trait Q7GRPRecordComponent extends Q7GRPRecordOps with Q7GRPRecordImplicits { self: DeepDSL => }

trait Q9GRPRecordOps extends Base { this: DeepDSL =>
  implicit class Q9GRPRecordRep(self: Rep[Q9GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q9GRPRecordGetField(self, key)
    def O_YEAR: Rep[Long] = q9GRPRecord_Field_O_YEAR(self)
    def NATION: Rep[OptimalString] = q9GRPRecord_Field_NATION(self)
  }
  object Q9GRPRecord {

  }
  // constructors
  def __newQ9GRPRecord(NATION: Rep[OptimalString], O_YEAR: Rep[Long]): Rep[Q9GRPRecord] = q9GRPRecordNew(NATION, O_YEAR)
  // case classes
  case class Q9GRPRecordNew(NATION: Rep[OptimalString], O_YEAR: Rep[Long]) extends ConstructorDef[Q9GRPRecord](List(), "Q9GRPRecord", List(List(NATION, O_YEAR))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q9GRPRecordGetField(self: Rep[Q9GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q9GRPRecord_Field_O_YEAR(self: Rep[Q9GRPRecord]) extends FieldDef[Long](self, "O_YEAR") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q9GRPRecord_Field_NATION(self: Rep[Q9GRPRecord]) extends FieldDef[OptimalString](self, "NATION") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q9GRPRecordNew(NATION: Rep[OptimalString], O_YEAR: Rep[Long]): Rep[Q9GRPRecord] = Q9GRPRecordNew(NATION, O_YEAR)
  def q9GRPRecordGetField(self: Rep[Q9GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q9GRPRecordGetField(self, key)
  def q9GRPRecord_Field_O_YEAR(self: Rep[Q9GRPRecord]): Rep[Long] = Q9GRPRecord_Field_O_YEAR(self)
  def q9GRPRecord_Field_NATION(self: Rep[Q9GRPRecord]): Rep[OptimalString] = Q9GRPRecord_Field_NATION(self)
  type Q9GRPRecord = ch.epfl.data.legobase.queryengine.Q9GRPRecord
  case object Q9GRPRecordType extends TypeRep[Q9GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q9GRPRecordType
    val name = "Q9GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q9GRPRecord]
  }
  implicit val typeQ9GRPRecord = Q9GRPRecordType
}
trait Q9GRPRecordImplicits { this: Q9GRPRecordComponent =>
  // Add implicit conversions here!
}
trait Q9GRPRecordImplementations { self: DeepDSL =>

}
trait Q9GRPRecordComponent extends Q9GRPRecordOps with Q9GRPRecordImplicits { self: DeepDSL => }

trait Q10GRPRecordOps extends Base { this: DeepDSL =>
  implicit class Q10GRPRecordRep(self: Rep[Q10GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q10GRPRecordGetField(self, key)
    def C_COMMENT: Rep[OptimalString] = q10GRPRecord_Field_C_COMMENT(self)
    def C_ADDRESS: Rep[OptimalString] = q10GRPRecord_Field_C_ADDRESS(self)
    def N_NAME: Rep[OptimalString] = q10GRPRecord_Field_N_NAME(self)
    def C_PHONE: Rep[OptimalString] = q10GRPRecord_Field_C_PHONE(self)
    def C_ACCTBAL: Rep[Double] = q10GRPRecord_Field_C_ACCTBAL(self)
    def C_NAME: Rep[OptimalString] = q10GRPRecord_Field_C_NAME(self)
    def C_CUSTKEY: Rep[Int] = q10GRPRecord_Field_C_CUSTKEY(self)
  }
  object Q10GRPRecord {

  }
  // constructors
  def __newQ10GRPRecord(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_PHONE: Rep[OptimalString], N_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[Q10GRPRecord] = q10GRPRecordNew(C_CUSTKEY, C_NAME, C_ACCTBAL, C_PHONE, N_NAME, C_ADDRESS, C_COMMENT)
  // case classes
  case class Q10GRPRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_PHONE: Rep[OptimalString], N_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_COMMENT: Rep[OptimalString]) extends ConstructorDef[Q10GRPRecord](List(), "Q10GRPRecord", List(List(C_CUSTKEY, C_NAME, C_ACCTBAL, C_PHONE, N_NAME, C_ADDRESS, C_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q10GRPRecordGetField(self: Rep[Q10GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q10GRPRecord_Field_C_COMMENT(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "C_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_ADDRESS(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "C_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_N_NAME(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "N_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_PHONE(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "C_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_ACCTBAL(self: Rep[Q10GRPRecord]) extends FieldDef[Double](self, "C_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_NAME(self: Rep[Q10GRPRecord]) extends FieldDef[OptimalString](self, "C_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q10GRPRecord_Field_C_CUSTKEY(self: Rep[Q10GRPRecord]) extends FieldDef[Int](self, "C_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q10GRPRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_PHONE: Rep[OptimalString], N_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[Q10GRPRecord] = Q10GRPRecordNew(C_CUSTKEY, C_NAME, C_ACCTBAL, C_PHONE, N_NAME, C_ADDRESS, C_COMMENT)
  def q10GRPRecordGetField(self: Rep[Q10GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q10GRPRecordGetField(self, key)
  def q10GRPRecord_Field_C_COMMENT(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_C_COMMENT(self)
  def q10GRPRecord_Field_C_ADDRESS(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_C_ADDRESS(self)
  def q10GRPRecord_Field_N_NAME(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_N_NAME(self)
  def q10GRPRecord_Field_C_PHONE(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_C_PHONE(self)
  def q10GRPRecord_Field_C_ACCTBAL(self: Rep[Q10GRPRecord]): Rep[Double] = Q10GRPRecord_Field_C_ACCTBAL(self)
  def q10GRPRecord_Field_C_NAME(self: Rep[Q10GRPRecord]): Rep[OptimalString] = Q10GRPRecord_Field_C_NAME(self)
  def q10GRPRecord_Field_C_CUSTKEY(self: Rep[Q10GRPRecord]): Rep[Int] = Q10GRPRecord_Field_C_CUSTKEY(self)
  type Q10GRPRecord = ch.epfl.data.legobase.queryengine.Q10GRPRecord
  case object Q10GRPRecordType extends TypeRep[Q10GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q10GRPRecordType
    val name = "Q10GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q10GRPRecord]
  }
  implicit val typeQ10GRPRecord = Q10GRPRecordType
}
trait Q10GRPRecordImplicits { this: Q10GRPRecordComponent =>
  // Add implicit conversions here!
}
trait Q10GRPRecordImplementations { self: DeepDSL =>

}
trait Q10GRPRecordComponent extends Q10GRPRecordOps with Q10GRPRecordImplicits { self: DeepDSL => }

trait Q16GRPRecord1Ops extends Base { this: DeepDSL =>
  implicit class Q16GRPRecord1Rep(self: Rep[Q16GRPRecord1]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q16GRPRecord1GetField(self, key)
    def PS_SUPPKEY: Rep[Int] = q16GRPRecord1_Field_PS_SUPPKEY(self)
    def P_SIZE: Rep[Int] = q16GRPRecord1_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = q16GRPRecord1_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = q16GRPRecord1_Field_P_BRAND(self)
  }
  object Q16GRPRecord1 {

  }
  // constructors
  def __newQ16GRPRecord1(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], PS_SUPPKEY: Rep[Int]): Rep[Q16GRPRecord1] = q16GRPRecord1New(P_BRAND, P_TYPE, P_SIZE, PS_SUPPKEY)
  // case classes
  case class Q16GRPRecord1New(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], PS_SUPPKEY: Rep[Int]) extends ConstructorDef[Q16GRPRecord1](List(), "Q16GRPRecord1", List(List(P_BRAND, P_TYPE, P_SIZE, PS_SUPPKEY))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q16GRPRecord1GetField(self: Rep[Q16GRPRecord1], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q16GRPRecord1_Field_PS_SUPPKEY(self: Rep[Q16GRPRecord1]) extends FieldDef[Int](self, "PS_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord1_Field_P_SIZE(self: Rep[Q16GRPRecord1]) extends FieldDef[Int](self, "P_SIZE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord1_Field_P_TYPE(self: Rep[Q16GRPRecord1]) extends FieldDef[OptimalString](self, "P_TYPE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord1_Field_P_BRAND(self: Rep[Q16GRPRecord1]) extends FieldDef[OptimalString](self, "P_BRAND") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q16GRPRecord1New(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], PS_SUPPKEY: Rep[Int]): Rep[Q16GRPRecord1] = Q16GRPRecord1New(P_BRAND, P_TYPE, P_SIZE, PS_SUPPKEY)
  def q16GRPRecord1GetField(self: Rep[Q16GRPRecord1], key: Rep[String]): Rep[Option[Any]] = Q16GRPRecord1GetField(self, key)
  def q16GRPRecord1_Field_PS_SUPPKEY(self: Rep[Q16GRPRecord1]): Rep[Int] = Q16GRPRecord1_Field_PS_SUPPKEY(self)
  def q16GRPRecord1_Field_P_SIZE(self: Rep[Q16GRPRecord1]): Rep[Int] = Q16GRPRecord1_Field_P_SIZE(self)
  def q16GRPRecord1_Field_P_TYPE(self: Rep[Q16GRPRecord1]): Rep[OptimalString] = Q16GRPRecord1_Field_P_TYPE(self)
  def q16GRPRecord1_Field_P_BRAND(self: Rep[Q16GRPRecord1]): Rep[OptimalString] = Q16GRPRecord1_Field_P_BRAND(self)
  type Q16GRPRecord1 = ch.epfl.data.legobase.queryengine.Q16GRPRecord1
  case object Q16GRPRecord1Type extends TypeRep[Q16GRPRecord1] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q16GRPRecord1Type
    val name = "Q16GRPRecord1"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q16GRPRecord1]
  }
  implicit val typeQ16GRPRecord1 = Q16GRPRecord1Type
}
trait Q16GRPRecord1Implicits { this: Q16GRPRecord1Component =>
  // Add implicit conversions here!
}
trait Q16GRPRecord1Implementations { self: DeepDSL =>

}
trait Q16GRPRecord1Component extends Q16GRPRecord1Ops with Q16GRPRecord1Implicits { self: DeepDSL => }

trait Q16GRPRecord2Ops extends Base { this: DeepDSL =>
  implicit class Q16GRPRecord2Rep(self: Rep[Q16GRPRecord2]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q16GRPRecord2GetField(self, key)
    def P_SIZE: Rep[Int] = q16GRPRecord2_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = q16GRPRecord2_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = q16GRPRecord2_Field_P_BRAND(self)
  }
  object Q16GRPRecord2 {

  }
  // constructors
  def __newQ16GRPRecord2(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int]): Rep[Q16GRPRecord2] = q16GRPRecord2New(P_BRAND, P_TYPE, P_SIZE)
  // case classes
  case class Q16GRPRecord2New(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int]) extends ConstructorDef[Q16GRPRecord2](List(), "Q16GRPRecord2", List(List(P_BRAND, P_TYPE, P_SIZE))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q16GRPRecord2GetField(self: Rep[Q16GRPRecord2], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q16GRPRecord2_Field_P_SIZE(self: Rep[Q16GRPRecord2]) extends FieldDef[Int](self, "P_SIZE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord2_Field_P_TYPE(self: Rep[Q16GRPRecord2]) extends FieldDef[OptimalString](self, "P_TYPE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q16GRPRecord2_Field_P_BRAND(self: Rep[Q16GRPRecord2]) extends FieldDef[OptimalString](self, "P_BRAND") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q16GRPRecord2New(P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int]): Rep[Q16GRPRecord2] = Q16GRPRecord2New(P_BRAND, P_TYPE, P_SIZE)
  def q16GRPRecord2GetField(self: Rep[Q16GRPRecord2], key: Rep[String]): Rep[Option[Any]] = Q16GRPRecord2GetField(self, key)
  def q16GRPRecord2_Field_P_SIZE(self: Rep[Q16GRPRecord2]): Rep[Int] = Q16GRPRecord2_Field_P_SIZE(self)
  def q16GRPRecord2_Field_P_TYPE(self: Rep[Q16GRPRecord2]): Rep[OptimalString] = Q16GRPRecord2_Field_P_TYPE(self)
  def q16GRPRecord2_Field_P_BRAND(self: Rep[Q16GRPRecord2]): Rep[OptimalString] = Q16GRPRecord2_Field_P_BRAND(self)
  type Q16GRPRecord2 = ch.epfl.data.legobase.queryengine.Q16GRPRecord2
  case object Q16GRPRecord2Type extends TypeRep[Q16GRPRecord2] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q16GRPRecord2Type
    val name = "Q16GRPRecord2"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q16GRPRecord2]
  }
  implicit val typeQ16GRPRecord2 = Q16GRPRecord2Type
}
trait Q16GRPRecord2Implicits { this: Q16GRPRecord2Component =>
  // Add implicit conversions here!
}
trait Q16GRPRecord2Implementations { self: DeepDSL =>

}
trait Q16GRPRecord2Component extends Q16GRPRecord2Ops with Q16GRPRecord2Implicits { self: DeepDSL => }

trait Q18GRPRecordOps extends Base { this: DeepDSL =>
  implicit class Q18GRPRecordRep(self: Rep[Q18GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q18GRPRecordGetField(self, key)
    def O_TOTALPRICE: Rep[Double] = q18GRPRecord_Field_O_TOTALPRICE(self)
    def O_ORDERDATE: Rep[Long] = q18GRPRecord_Field_O_ORDERDATE(self)
    def O_ORDERKEY: Rep[Int] = q18GRPRecord_Field_O_ORDERKEY(self)
    def C_CUSTKEY: Rep[Int] = q18GRPRecord_Field_C_CUSTKEY(self)
    def C_NAME: Rep[OptimalString] = q18GRPRecord_Field_C_NAME(self)
  }
  object Q18GRPRecord {

  }
  // constructors
  def __newQ18GRPRecord(C_NAME: Rep[OptimalString], C_CUSTKEY: Rep[Int], O_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_TOTALPRICE: Rep[Double]): Rep[Q18GRPRecord] = q18GRPRecordNew(C_NAME, C_CUSTKEY, O_ORDERKEY, O_ORDERDATE, O_TOTALPRICE)
  // case classes
  case class Q18GRPRecordNew(C_NAME: Rep[OptimalString], C_CUSTKEY: Rep[Int], O_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_TOTALPRICE: Rep[Double]) extends ConstructorDef[Q18GRPRecord](List(), "Q18GRPRecord", List(List(C_NAME, C_CUSTKEY, O_ORDERKEY, O_ORDERDATE, O_TOTALPRICE))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q18GRPRecordGetField(self: Rep[Q18GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q18GRPRecord_Field_O_TOTALPRICE(self: Rep[Q18GRPRecord]) extends FieldDef[Double](self, "O_TOTALPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q18GRPRecord_Field_O_ORDERDATE(self: Rep[Q18GRPRecord]) extends FieldDef[Long](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q18GRPRecord_Field_O_ORDERKEY(self: Rep[Q18GRPRecord]) extends FieldDef[Int](self, "O_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q18GRPRecord_Field_C_CUSTKEY(self: Rep[Q18GRPRecord]) extends FieldDef[Int](self, "C_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q18GRPRecord_Field_C_NAME(self: Rep[Q18GRPRecord]) extends FieldDef[OptimalString](self, "C_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q18GRPRecordNew(C_NAME: Rep[OptimalString], C_CUSTKEY: Rep[Int], O_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_TOTALPRICE: Rep[Double]): Rep[Q18GRPRecord] = Q18GRPRecordNew(C_NAME, C_CUSTKEY, O_ORDERKEY, O_ORDERDATE, O_TOTALPRICE)
  def q18GRPRecordGetField(self: Rep[Q18GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q18GRPRecordGetField(self, key)
  def q18GRPRecord_Field_O_TOTALPRICE(self: Rep[Q18GRPRecord]): Rep[Double] = Q18GRPRecord_Field_O_TOTALPRICE(self)
  def q18GRPRecord_Field_O_ORDERDATE(self: Rep[Q18GRPRecord]): Rep[Long] = Q18GRPRecord_Field_O_ORDERDATE(self)
  def q18GRPRecord_Field_O_ORDERKEY(self: Rep[Q18GRPRecord]): Rep[Int] = Q18GRPRecord_Field_O_ORDERKEY(self)
  def q18GRPRecord_Field_C_CUSTKEY(self: Rep[Q18GRPRecord]): Rep[Int] = Q18GRPRecord_Field_C_CUSTKEY(self)
  def q18GRPRecord_Field_C_NAME(self: Rep[Q18GRPRecord]): Rep[OptimalString] = Q18GRPRecord_Field_C_NAME(self)
  type Q18GRPRecord = ch.epfl.data.legobase.queryengine.Q18GRPRecord
  case object Q18GRPRecordType extends TypeRep[Q18GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q18GRPRecordType
    val name = "Q18GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q18GRPRecord]
  }
  implicit val typeQ18GRPRecord = Q18GRPRecordType
}
trait Q18GRPRecordImplicits { this: Q18GRPRecordComponent =>
  // Add implicit conversions here!
}
trait Q18GRPRecordImplementations { self: DeepDSL =>

}
trait Q18GRPRecordComponent extends Q18GRPRecordOps with Q18GRPRecordImplicits { self: DeepDSL => }

trait Q20GRPRecordOps extends Base { this: DeepDSL =>
  implicit class Q20GRPRecordRep(self: Rep[Q20GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q20GRPRecordGetField(self, key)
    def PS_AVAILQTY: Rep[Int] = q20GRPRecord_Field_PS_AVAILQTY(self)
    def PS_SUPPKEY: Rep[Int] = q20GRPRecord_Field_PS_SUPPKEY(self)
    def PS_PARTKEY: Rep[Int] = q20GRPRecord_Field_PS_PARTKEY(self)
  }
  object Q20GRPRecord {

  }
  // constructors
  def __newQ20GRPRecord(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int]): Rep[Q20GRPRecord] = q20GRPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY)
  // case classes
  case class Q20GRPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int]) extends ConstructorDef[Q20GRPRecord](List(), "Q20GRPRecord", List(List(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q20GRPRecordGetField(self: Rep[Q20GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q20GRPRecord_Field_PS_AVAILQTY(self: Rep[Q20GRPRecord]) extends FieldDef[Int](self, "PS_AVAILQTY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q20GRPRecord_Field_PS_SUPPKEY(self: Rep[Q20GRPRecord]) extends FieldDef[Int](self, "PS_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q20GRPRecord_Field_PS_PARTKEY(self: Rep[Q20GRPRecord]) extends FieldDef[Int](self, "PS_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q20GRPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int]): Rep[Q20GRPRecord] = Q20GRPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY)
  def q20GRPRecordGetField(self: Rep[Q20GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q20GRPRecordGetField(self, key)
  def q20GRPRecord_Field_PS_AVAILQTY(self: Rep[Q20GRPRecord]): Rep[Int] = Q20GRPRecord_Field_PS_AVAILQTY(self)
  def q20GRPRecord_Field_PS_SUPPKEY(self: Rep[Q20GRPRecord]): Rep[Int] = Q20GRPRecord_Field_PS_SUPPKEY(self)
  def q20GRPRecord_Field_PS_PARTKEY(self: Rep[Q20GRPRecord]): Rep[Int] = Q20GRPRecord_Field_PS_PARTKEY(self)
  type Q20GRPRecord = ch.epfl.data.legobase.queryengine.Q20GRPRecord
  case object Q20GRPRecordType extends TypeRep[Q20GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q20GRPRecordType
    val name = "Q20GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q20GRPRecord]
  }
  implicit val typeQ20GRPRecord = Q20GRPRecordType
}
trait Q20GRPRecordImplicits { this: Q20GRPRecordComponent =>
  // Add implicit conversions here!
}
trait Q20GRPRecordImplementations { self: DeepDSL =>

}
trait Q20GRPRecordComponent extends Q20GRPRecordOps with Q20GRPRecordImplicits { self: DeepDSL => }

trait AGGRecordOps extends Base { this: DeepDSL =>
  implicit class AGGRecordRep[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = aGGRecordGetField[B](self, key)(typeB)
    def aggs: Rep[Array[Double]] = aGGRecord_Field_Aggs[B](self)(typeB)
    def key: Rep[B] = aGGRecord_Field_Key[B](self)(typeB)
  }
  object AGGRecord {

  }
  // constructors
  def __newAGGRecord[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = aGGRecordNew[B](key, aggs)(typeB)
  // case classes
  case class AGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit val typeB: TypeRep[B]) extends ConstructorDef[AGGRecord[B]](List(typeB), "AGGRecord", List(List(key, aggs))) {
    override def curriedConstructor = (copy[B] _).curried
  }

  case class AGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit val typeB: TypeRep[B]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy[B] _).curried
  }

  case class AGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit val typeB: TypeRep[B]) extends FieldDef[Array[Double]](self, "aggs") {
    override def curriedConstructor = (copy[B] _)
    override def isPure = true

  }

  case class AGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit val typeB: TypeRep[B]) extends FieldDef[B](self, "key") {
    override def curriedConstructor = (copy[B] _)
    override def isPure = true

  }

  // method definitions
  def aGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = AGGRecordNew[B](key, aggs)
  def aGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit typeB: TypeRep[B]): Rep[Option[Any]] = AGGRecordGetField[B](self, key)
  def aGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[Array[Double]] = AGGRecord_Field_Aggs[B](self)
  def aGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[B] = AGGRecord_Field_Key[B](self)
  type AGGRecord[B] = ch.epfl.data.legobase.queryengine.AGGRecord[B]
  case class AGGRecordType[B](typeB: TypeRep[B]) extends TypeRep[AGGRecord[B]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = AGGRecordType(newArguments(0).asInstanceOf[TypeRep[_]])
    private implicit val tagB = typeB.typeTag
    val name = s"AGGRecord[${typeB.name}]"
    val typeArguments = List(typeB)
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[AGGRecord[B]]
  }
  implicit def typeAGGRecord[B: TypeRep] = AGGRecordType(implicitly[TypeRep[B]])
}
trait AGGRecordImplicits { this: AGGRecordComponent =>
  // Add implicit conversions here!
}
trait AGGRecordImplementations { self: DeepDSL =>

}
trait AGGRecordComponent extends AGGRecordOps with AGGRecordImplicits { self: DeepDSL => }

trait GenericEngineOps extends Base { this: DeepDSL =>
  implicit class GenericEngineRep(self: Rep[GenericEngine]) {

  }
  object GenericEngine {
    def runQuery[T](query: => Rep[T])(implicit typeT: TypeRep[T]): Rep[T] = genericEngineRunQueryObject[T](query)(typeT)
    def dateToString(long: Rep[Long]): Rep[String] = genericEngineDateToStringObject(long)
    def dateToYear(long: Rep[Long]): Rep[Int] = genericEngineDateToYearObject(long)
    def parseDate(x: Rep[String]): Rep[Long] = genericEngineParseDateObject(x)
    def parseString(x: Rep[String]): Rep[OptimalString] = genericEngineParseStringObject(x)
  }
  // constructors

  // case classes
  case class GenericEngineRunQueryObject[T](queryOutput: Block[T])(implicit val typeT: TypeRep[T]) extends FunctionDef[T](None, "GenericEngine.runQuery", List(List(queryOutput))) {
    override def curriedConstructor = (copy[T] _)
  }

  case class GenericEngineDateToStringObject(long: Rep[Long]) extends FunctionDef[String](None, "GenericEngine.dateToString", List(List(long))) {
    override def curriedConstructor = (copy _)
  }

  case class GenericEngineDateToYearObject(long: Rep[Long]) extends FunctionDef[Int](None, "GenericEngine.dateToYear", List(List(long))) {
    override def curriedConstructor = (copy _)
  }

  case class GenericEngineParseDateObject(x: Rep[String]) extends FunctionDef[Long](None, "GenericEngine.parseDate", List(List(x))) {
    override def curriedConstructor = (copy _)
  }

  case class GenericEngineParseStringObject(x: Rep[String]) extends FunctionDef[OptimalString](None, "GenericEngine.parseString", List(List(x))) {
    override def curriedConstructor = (copy _)
  }

  // method definitions
  def genericEngineRunQueryObject[T](query: => Rep[T])(implicit typeT: TypeRep[T]): Rep[T] = {
    val queryOutput = reifyBlock(query)
    GenericEngineRunQueryObject[T](queryOutput)
  }
  def genericEngineDateToStringObject(long: Rep[Long]): Rep[String] = GenericEngineDateToStringObject(long)
  def genericEngineDateToYearObject(long: Rep[Long]): Rep[Int] = GenericEngineDateToYearObject(long)
  def genericEngineParseDateObject(x: Rep[String]): Rep[Long] = GenericEngineParseDateObject(x)
  def genericEngineParseStringObject(x: Rep[String]): Rep[OptimalString] = GenericEngineParseStringObject(x)
  type GenericEngine = ch.epfl.data.legobase.queryengine.GenericEngine
  case object GenericEngineType extends TypeRep[GenericEngine] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = GenericEngineType
    val name = "GenericEngine"
    val typeArguments = Nil

    val typeTag = scala.reflect.runtime.universe.typeTag[GenericEngine]
  }
  implicit val typeGenericEngine = GenericEngineType
}
trait GenericEngineImplicits { this: GenericEngineComponent =>
  // Add implicit conversions here!
}
trait GenericEngineImplementations { self: DeepDSL =>

}
trait GenericEngineComponent extends GenericEngineOps with GenericEngineImplicits { self: DeepDSL => }

trait LINEITEMRecordOps extends Base { this: DeepDSL =>
  implicit class LINEITEMRecordRep(self: Rep[LINEITEMRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = lINEITEMRecordGetField(self, key)
    def L_COMMENT: Rep[OptimalString] = lINEITEMRecord_Field_L_COMMENT(self)
    def L_SHIPMODE: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPMODE(self)
    def L_SHIPINSTRUCT: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPINSTRUCT(self)
    def L_RECEIPTDATE: Rep[Long] = lINEITEMRecord_Field_L_RECEIPTDATE(self)
    def L_COMMITDATE: Rep[Long] = lINEITEMRecord_Field_L_COMMITDATE(self)
    def L_SHIPDATE: Rep[Long] = lINEITEMRecord_Field_L_SHIPDATE(self)
    def L_LINESTATUS: Rep[Character] = lINEITEMRecord_Field_L_LINESTATUS(self)
    def L_RETURNFLAG: Rep[Character] = lINEITEMRecord_Field_L_RETURNFLAG(self)
    def L_TAX: Rep[Double] = lINEITEMRecord_Field_L_TAX(self)
    def L_DISCOUNT: Rep[Double] = lINEITEMRecord_Field_L_DISCOUNT(self)
    def L_EXTENDEDPRICE: Rep[Double] = lINEITEMRecord_Field_L_EXTENDEDPRICE(self)
    def L_QUANTITY: Rep[Double] = lINEITEMRecord_Field_L_QUANTITY(self)
    def L_LINENUMBER: Rep[Int] = lINEITEMRecord_Field_L_LINENUMBER(self)
    def L_SUPPKEY: Rep[Int] = lINEITEMRecord_Field_L_SUPPKEY(self)
    def L_PARTKEY: Rep[Int] = lINEITEMRecord_Field_L_PARTKEY(self)
    def L_ORDERKEY: Rep[Int] = lINEITEMRecord_Field_L_ORDERKEY(self)
  }
  object LINEITEMRecord {

  }
  // constructors
  def __newLINEITEMRecord(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character], L_SHIPDATE: Rep[Long], L_COMMITDATE: Rep[Long], L_RECEIPTDATE: Rep[Long], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = lINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  // case classes
  case class LINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character], L_SHIPDATE: Rep[Long], L_COMMITDATE: Rep[Long], L_RECEIPTDATE: Rep[Long], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]) extends ConstructorDef[LINEITEMRecord](List(), "LINEITEMRecord", List(List(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class LINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class LINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_SHIPMODE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_SHIPINSTRUCT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Long](self, "L_RECEIPTDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Long](self, "L_COMMITDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Long](self, "L_SHIPDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]) extends FieldDef[Character](self, "L_LINESTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]) extends FieldDef[Character](self, "L_RETURNFLAG") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_TAX") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_DISCOUNT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_EXTENDEDPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_QUANTITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_LINENUMBER") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def lINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character], L_SHIPDATE: Rep[Long], L_COMMITDATE: Rep[Long], L_RECEIPTDATE: Rep[Long], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = LINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  def lINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]): Rep[Option[Any]] = LINEITEMRecordGetField(self, key)
  def lINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_COMMENT(self)
  def lINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPMODE(self)
  def lINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPINSTRUCT(self)
  def lINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]): Rep[Long] = LINEITEMRecord_Field_L_RECEIPTDATE(self)
  def lINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]): Rep[Long] = LINEITEMRecord_Field_L_COMMITDATE(self)
  def lINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]): Rep[Long] = LINEITEMRecord_Field_L_SHIPDATE(self)
  def lINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]): Rep[Character] = LINEITEMRecord_Field_L_LINESTATUS(self)
  def lINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]): Rep[Character] = LINEITEMRecord_Field_L_RETURNFLAG(self)
  def lINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_TAX(self)
  def lINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_DISCOUNT(self)
  def lINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_EXTENDEDPRICE(self)
  def lINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_QUANTITY(self)
  def lINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_LINENUMBER(self)
  def lINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_SUPPKEY(self)
  def lINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_PARTKEY(self)
  def lINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_ORDERKEY(self)
  type LINEITEMRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.LINEITEMRecord
  case object LINEITEMRecordType extends TypeRep[LINEITEMRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = LINEITEMRecordType
    val name = "LINEITEMRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[LINEITEMRecord]
  }
  implicit val typeLINEITEMRecord = LINEITEMRecordType
}
trait LINEITEMRecordImplicits { this: LINEITEMRecordComponent =>
  // Add implicit conversions here!
}
trait LINEITEMRecordImplementations { self: DeepDSL =>

}
trait LINEITEMRecordComponent extends LINEITEMRecordOps with LINEITEMRecordImplicits { self: DeepDSL => }

trait SUPPLIERRecordOps extends Base { this: DeepDSL =>
  implicit class SUPPLIERRecordRep(self: Rep[SUPPLIERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = sUPPLIERRecordGetField(self, key)
    def S_COMMENT: Rep[OptimalString] = sUPPLIERRecord_Field_S_COMMENT(self)
    def S_ACCTBAL: Rep[Double] = sUPPLIERRecord_Field_S_ACCTBAL(self)
    def S_PHONE: Rep[OptimalString] = sUPPLIERRecord_Field_S_PHONE(self)
    def S_NATIONKEY: Rep[Int] = sUPPLIERRecord_Field_S_NATIONKEY(self)
    def S_ADDRESS: Rep[OptimalString] = sUPPLIERRecord_Field_S_ADDRESS(self)
    def S_NAME: Rep[OptimalString] = sUPPLIERRecord_Field_S_NAME(self)
    def S_SUPPKEY: Rep[Int] = sUPPLIERRecord_Field_S_SUPPKEY(self)
  }
  object SUPPLIERRecord {

  }
  // constructors
  def __newSUPPLIERRecord(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = sUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  // case classes
  case class SUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]) extends ConstructorDef[SUPPLIERRecord](List(), "SUPPLIERRecord", List(List(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class SUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class SUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]) extends FieldDef[Double](self, "S_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]) extends FieldDef[Int](self, "S_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]) extends FieldDef[Int](self, "S_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def sUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = SUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  def sUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]): Rep[Option[Any]] = SUPPLIERRecordGetField(self, key)
  def sUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_COMMENT(self)
  def sUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]): Rep[Double] = SUPPLIERRecord_Field_S_ACCTBAL(self)
  def sUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_PHONE(self)
  def sUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_NATIONKEY(self)
  def sUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_ADDRESS(self)
  def sUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_NAME(self)
  def sUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_SUPPKEY(self)
  type SUPPLIERRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.SUPPLIERRecord
  case object SUPPLIERRecordType extends TypeRep[SUPPLIERRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = SUPPLIERRecordType
    val name = "SUPPLIERRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[SUPPLIERRecord]
  }
  implicit val typeSUPPLIERRecord = SUPPLIERRecordType
}
trait SUPPLIERRecordImplicits { this: SUPPLIERRecordComponent =>
  // Add implicit conversions here!
}
trait SUPPLIERRecordImplementations { self: DeepDSL =>

}
trait SUPPLIERRecordComponent extends SUPPLIERRecordOps with SUPPLIERRecordImplicits { self: DeepDSL => }

trait PARTSUPPRecordOps extends Base { this: DeepDSL =>
  implicit class PARTSUPPRecordRep(self: Rep[PARTSUPPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTSUPPRecordGetField(self, key)
    def PS_COMMENT: Rep[OptimalString] = pARTSUPPRecord_Field_PS_COMMENT(self)
    def PS_SUPPLYCOST: Rep[Double] = pARTSUPPRecord_Field_PS_SUPPLYCOST(self)
    def PS_AVAILQTY: Rep[Int] = pARTSUPPRecord_Field_PS_AVAILQTY(self)
    def PS_SUPPKEY: Rep[Int] = pARTSUPPRecord_Field_PS_SUPPKEY(self)
    def PS_PARTKEY: Rep[Int] = pARTSUPPRecord_Field_PS_PARTKEY(self)
  }
  object PARTSUPPRecord {

  }
  // constructors
  def __newPARTSUPPRecord(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = pARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  // case classes
  case class PARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]) extends ConstructorDef[PARTSUPPRecord](List(), "PARTSUPPRecord", List(List(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]) extends FieldDef[OptimalString](self, "PS_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]) extends FieldDef[Double](self, "PS_SUPPLYCOST") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_AVAILQTY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def pARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = PARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  def pARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]): Rep[Option[Any]] = PARTSUPPRecordGetField(self, key)
  def pARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]): Rep[OptimalString] = PARTSUPPRecord_Field_PS_COMMENT(self)
  def pARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]): Rep[Double] = PARTSUPPRecord_Field_PS_SUPPLYCOST(self)
  def pARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_AVAILQTY(self)
  def pARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_SUPPKEY(self)
  def pARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_PARTKEY(self)
  type PARTSUPPRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.PARTSUPPRecord
  case object PARTSUPPRecordType extends TypeRep[PARTSUPPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = PARTSUPPRecordType
    val name = "PARTSUPPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[PARTSUPPRecord]
  }
  implicit val typePARTSUPPRecord = PARTSUPPRecordType
}
trait PARTSUPPRecordImplicits { this: PARTSUPPRecordComponent =>
  // Add implicit conversions here!
}
trait PARTSUPPRecordImplementations { self: DeepDSL =>

}
trait PARTSUPPRecordComponent extends PARTSUPPRecordOps with PARTSUPPRecordImplicits { self: DeepDSL => }

trait REGIONRecordOps extends Base { this: DeepDSL =>
  implicit class REGIONRecordRep(self: Rep[REGIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = rEGIONRecordGetField(self, key)
    def R_COMMENT: Rep[OptimalString] = rEGIONRecord_Field_R_COMMENT(self)
    def R_NAME: Rep[OptimalString] = rEGIONRecord_Field_R_NAME(self)
    def R_REGIONKEY: Rep[Int] = rEGIONRecord_Field_R_REGIONKEY(self)
  }
  object REGIONRecord {

  }
  // constructors
  def __newREGIONRecord(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = rEGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)
  // case classes
  case class REGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]) extends ConstructorDef[REGIONRecord](List(), "REGIONRecord", List(List(R_REGIONKEY, R_NAME, R_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class REGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class REGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]) extends FieldDef[OptimalString](self, "R_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class REGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]) extends FieldDef[OptimalString](self, "R_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class REGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]) extends FieldDef[Int](self, "R_REGIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def rEGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = REGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)
  def rEGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]): Rep[Option[Any]] = REGIONRecordGetField(self, key)
  def rEGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_COMMENT(self)
  def rEGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_NAME(self)
  def rEGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]): Rep[Int] = REGIONRecord_Field_R_REGIONKEY(self)
  type REGIONRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.REGIONRecord
  case object REGIONRecordType extends TypeRep[REGIONRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = REGIONRecordType
    val name = "REGIONRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[REGIONRecord]
  }
  implicit val typeREGIONRecord = REGIONRecordType
}
trait REGIONRecordImplicits { this: REGIONRecordComponent =>
  // Add implicit conversions here!
}
trait REGIONRecordImplementations { self: DeepDSL =>

}
trait REGIONRecordComponent extends REGIONRecordOps with REGIONRecordImplicits { self: DeepDSL => }

trait NATIONRecordOps extends Base { this: DeepDSL =>
  implicit class NATIONRecordRep(self: Rep[NATIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = nATIONRecordGetField(self, key)
    def N_COMMENT: Rep[OptimalString] = nATIONRecord_Field_N_COMMENT(self)
    def N_REGIONKEY: Rep[Int] = nATIONRecord_Field_N_REGIONKEY(self)
    def N_NAME: Rep[OptimalString] = nATIONRecord_Field_N_NAME(self)
    def N_NATIONKEY: Rep[Int] = nATIONRecord_Field_N_NATIONKEY(self)
  }
  object NATIONRecord {

  }
  // constructors
  def __newNATIONRecord(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = nATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  // case classes
  case class NATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]) extends ConstructorDef[NATIONRecord](List(), "NATIONRecord", List(List(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class NATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class NATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]) extends FieldDef[OptimalString](self, "N_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]) extends FieldDef[Int](self, "N_REGIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]) extends FieldDef[OptimalString](self, "N_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]) extends FieldDef[Int](self, "N_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def nATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = NATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  def nATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]): Rep[Option[Any]] = NATIONRecordGetField(self, key)
  def nATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_COMMENT(self)
  def nATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_REGIONKEY(self)
  def nATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_NAME(self)
  def nATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_NATIONKEY(self)
  type NATIONRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.NATIONRecord
  case object NATIONRecordType extends TypeRep[NATIONRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = NATIONRecordType
    val name = "NATIONRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[NATIONRecord]
  }
  implicit val typeNATIONRecord = NATIONRecordType
}
trait NATIONRecordImplicits { this: NATIONRecordComponent =>
  // Add implicit conversions here!
}
trait NATIONRecordImplementations { self: DeepDSL =>

}
trait NATIONRecordComponent extends NATIONRecordOps with NATIONRecordImplicits { self: DeepDSL => }

trait PARTRecordOps extends Base { this: DeepDSL =>
  implicit class PARTRecordRep(self: Rep[PARTRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTRecordGetField(self, key)
    def P_COMMENT: Rep[OptimalString] = pARTRecord_Field_P_COMMENT(self)
    def P_RETAILPRICE: Rep[Double] = pARTRecord_Field_P_RETAILPRICE(self)
    def P_CONTAINER: Rep[OptimalString] = pARTRecord_Field_P_CONTAINER(self)
    def P_SIZE: Rep[Int] = pARTRecord_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = pARTRecord_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = pARTRecord_Field_P_BRAND(self)
    def P_MFGR: Rep[OptimalString] = pARTRecord_Field_P_MFGR(self)
    def P_NAME: Rep[OptimalString] = pARTRecord_Field_P_NAME(self)
    def P_PARTKEY: Rep[Int] = pARTRecord_Field_P_PARTKEY(self)
  }
  object PARTRecord {

  }
  // constructors
  def __newPARTRecord(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = pARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  // case classes
  case class PARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]) extends ConstructorDef[PARTRecord](List(), "PARTRecord", List(List(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]) extends FieldDef[Double](self, "P_RETAILPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_CONTAINER") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_SIZE(self: Rep[PARTRecord]) extends FieldDef[Int](self, "P_SIZE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_TYPE(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_TYPE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_BRAND(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_BRAND") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_MFGR(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_MFGR") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_NAME(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]) extends FieldDef[Int](self, "P_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def pARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = PARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  def pARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]): Rep[Option[Any]] = PARTRecordGetField(self, key)
  def pARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_COMMENT(self)
  def pARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]): Rep[Double] = PARTRecord_Field_P_RETAILPRICE(self)
  def pARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_CONTAINER(self)
  def pARTRecord_Field_P_SIZE(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_SIZE(self)
  def pARTRecord_Field_P_TYPE(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_TYPE(self)
  def pARTRecord_Field_P_BRAND(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_BRAND(self)
  def pARTRecord_Field_P_MFGR(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_MFGR(self)
  def pARTRecord_Field_P_NAME(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_NAME(self)
  def pARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_PARTKEY(self)
  type PARTRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.PARTRecord
  case object PARTRecordType extends TypeRep[PARTRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = PARTRecordType
    val name = "PARTRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[PARTRecord]
  }
  implicit val typePARTRecord = PARTRecordType
}
trait PARTRecordImplicits { this: PARTRecordComponent =>
  // Add implicit conversions here!
}
trait PARTRecordImplementations { self: DeepDSL =>

}
trait PARTRecordComponent extends PARTRecordOps with PARTRecordImplicits { self: DeepDSL => }

trait CUSTOMERRecordOps extends Base { this: DeepDSL =>
  implicit class CUSTOMERRecordRep(self: Rep[CUSTOMERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = cUSTOMERRecordGetField(self, key)
    def C_COMMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_COMMENT(self)
    def C_MKTSEGMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_MKTSEGMENT(self)
    def C_ACCTBAL: Rep[Double] = cUSTOMERRecord_Field_C_ACCTBAL(self)
    def C_PHONE: Rep[OptimalString] = cUSTOMERRecord_Field_C_PHONE(self)
    def C_NATIONKEY: Rep[Int] = cUSTOMERRecord_Field_C_NATIONKEY(self)
    def C_ADDRESS: Rep[OptimalString] = cUSTOMERRecord_Field_C_ADDRESS(self)
    def C_NAME: Rep[OptimalString] = cUSTOMERRecord_Field_C_NAME(self)
    def C_CUSTKEY: Rep[Int] = cUSTOMERRecord_Field_C_CUSTKEY(self)
  }
  object CUSTOMERRecord {

  }
  // constructors
  def __newCUSTOMERRecord(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = cUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  // case classes
  case class CUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]) extends ConstructorDef[CUSTOMERRecord](List(), "CUSTOMERRecord", List(List(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class CUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class CUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_MKTSEGMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]) extends FieldDef[Double](self, "C_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]) extends FieldDef[Int](self, "C_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]) extends FieldDef[Int](self, "C_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def cUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = CUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  def cUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]): Rep[Option[Any]] = CUSTOMERRecordGetField(self, key)
  def cUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_COMMENT(self)
  def cUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_MKTSEGMENT(self)
  def cUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]): Rep[Double] = CUSTOMERRecord_Field_C_ACCTBAL(self)
  def cUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_PHONE(self)
  def cUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_NATIONKEY(self)
  def cUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_ADDRESS(self)
  def cUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_NAME(self)
  def cUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_CUSTKEY(self)
  type CUSTOMERRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.CUSTOMERRecord
  case object CUSTOMERRecordType extends TypeRep[CUSTOMERRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = CUSTOMERRecordType
    val name = "CUSTOMERRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[CUSTOMERRecord]
  }
  implicit val typeCUSTOMERRecord = CUSTOMERRecordType
}
trait CUSTOMERRecordImplicits { this: CUSTOMERRecordComponent =>
  // Add implicit conversions here!
}
trait CUSTOMERRecordImplementations { self: DeepDSL =>

}
trait CUSTOMERRecordComponent extends CUSTOMERRecordOps with CUSTOMERRecordImplicits { self: DeepDSL => }

trait ORDERSRecordOps extends Base { this: DeepDSL =>
  implicit class ORDERSRecordRep(self: Rep[ORDERSRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = oRDERSRecordGetField(self, key)
    def O_COMMENT: Rep[OptimalString] = oRDERSRecord_Field_O_COMMENT(self)
    def O_SHIPPRIORITY: Rep[Int] = oRDERSRecord_Field_O_SHIPPRIORITY(self)
    def O_CLERK: Rep[OptimalString] = oRDERSRecord_Field_O_CLERK(self)
    def O_ORDERPRIORITY: Rep[OptimalString] = oRDERSRecord_Field_O_ORDERPRIORITY(self)
    def O_ORDERDATE: Rep[Long] = oRDERSRecord_Field_O_ORDERDATE(self)
    def O_TOTALPRICE: Rep[Double] = oRDERSRecord_Field_O_TOTALPRICE(self)
    def O_ORDERSTATUS: Rep[Character] = oRDERSRecord_Field_O_ORDERSTATUS(self)
    def O_CUSTKEY: Rep[Int] = oRDERSRecord_Field_O_CUSTKEY(self)
    def O_ORDERKEY: Rep[Int] = oRDERSRecord_Field_O_ORDERKEY(self)
  }
  object ORDERSRecord {

  }
  // constructors
  def __newORDERSRecord(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Character], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Long], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = oRDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  // case classes
  case class ORDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Character], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Long], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]) extends ConstructorDef[ORDERSRecord](List(), "ORDERSRecord", List(List(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class ORDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class ORDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_SHIPPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_CLERK") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_ORDERPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]) extends FieldDef[Long](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]) extends FieldDef[Double](self, "O_TOTALPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]) extends FieldDef[Character](self, "O_ORDERSTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def oRDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Character], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Long], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = ORDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  def oRDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]): Rep[Option[Any]] = ORDERSRecordGetField(self, key)
  def oRDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_COMMENT(self)
  def oRDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_SHIPPRIORITY(self)
  def oRDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_CLERK(self)
  def oRDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_ORDERPRIORITY(self)
  def oRDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]): Rep[Long] = ORDERSRecord_Field_O_ORDERDATE(self)
  def oRDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]): Rep[Double] = ORDERSRecord_Field_O_TOTALPRICE(self)
  def oRDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]): Rep[Character] = ORDERSRecord_Field_O_ORDERSTATUS(self)
  def oRDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_CUSTKEY(self)
  def oRDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_ORDERKEY(self)
  type ORDERSRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.ORDERSRecord
  case object ORDERSRecordType extends TypeRep[ORDERSRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = ORDERSRecordType
    val name = "ORDERSRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[ORDERSRecord]
  }
  implicit val typeORDERSRecord = ORDERSRecordType
}
trait ORDERSRecordImplicits { this: ORDERSRecordComponent =>
  // Add implicit conversions here!
}
trait ORDERSRecordImplementations { self: DeepDSL =>

}
trait ORDERSRecordComponent extends ORDERSRecordOps with ORDERSRecordImplicits { self: DeepDSL => }

trait OptimalStringOps extends Base { this: DeepDSL =>
  implicit class OptimalStringRep(self: Rep[OptimalString]) {
    def equals(o: Rep[Any]): Rep[Boolean] = optimalStringEquals(self, o)
    def apply(i: Rep[Int]): Rep[Byte] = optimalStringApply(self, i)
    def startsWith(o: Rep[OptimalString]): Rep[Boolean] = optimalStringStartsWith(self, o)
    def containsSlice(o: Rep[OptimalString]): Rep[Boolean] = optimalStringContainsSlice(self, o)
    def endsWith(o: Rep[OptimalString]): Rep[Boolean] = optimalStringEndsWith(self, o)
    def slice(start: Rep[Int], end: Rep[Int]): Rep[OptimalString] = optimalStringSlice(self, start, end)
    def indexOfSlice(o: Rep[OptimalString], i: Rep[Int]): Rep[Int] = optimalStringIndexOfSlice(self, o, i)
    def diff(o: Rep[OptimalString]): Rep[Int] = optimalStringDiff(self, o)
    def compare(o: Rep[OptimalString]): Rep[Int] = optimalStringCompare(self, o)
    def ===(o: Rep[OptimalString]): Rep[Boolean] = optimalString$eq$eq$eq(self, o)
    def =!=(o: Rep[OptimalString]): Rep[Boolean] = optimalString$eq$bang$eq(self, o)
    def +(o: Rep[Any]): Rep[OptimalString] = optimalString$plus(self, o)
    def string: Rep[String] = optimalStringString(self)
    def zip(o: Rep[OptimalString]): Rep[Array[Tuple2[Byte, Byte]]] = optimalStringZip(self, o)
    def foldLeft(c: Rep[Int])(f: Rep[((Int, Byte) => Int)]): Rep[Int] = optimalStringFoldLeft(self, c, f)
    def data: Rep[Array[Byte]] = optimalString_Field_Data(self)
  }
  object OptimalString {
    def apply(data: Rep[Array[Byte]]): Rep[OptimalString] = optimalStringApplyObject(data)
    def default: Rep[OptimalString] = optimalStringDefaultObject()
  }
  // constructors
  def __newOptimalString(data: Rep[Array[Byte]]): Rep[OptimalString] = optimalStringNew(data)
  // case classes
  case class OptimalStringNew(data: Rep[Array[Byte]]) extends ConstructorDef[OptimalString](List(), "OptimalString", List(List(data))) {
    override def curriedConstructor = (copy _)
  }

  case class OptimalStringEquals(self: Rep[OptimalString], o: Rep[Any]) extends FunctionDef[Boolean](Some(self), "equals", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringApply(self: Rep[OptimalString], i: Rep[Int]) extends FunctionDef[Byte](Some(self), "apply", List(List(i))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringStartsWith(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "startsWith", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringContainsSlice(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "containsSlice", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringEndsWith(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "endsWith", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringSlice(self: Rep[OptimalString], start: Rep[Int], end: Rep[Int]) extends FunctionDef[OptimalString](Some(self), "slice", List(List(start, end))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringIndexOfSlice(self: Rep[OptimalString], o: Rep[OptimalString], i: Rep[Int]) extends FunctionDef[Int](Some(self), "indexOfSlice", List(List(o, i))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringDiff(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Int](Some(self), "diff", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringCompare(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Int](Some(self), "compare", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalString$eq$eq$eq(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "===", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalString$eq$bang$eq(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "=!=", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalString$plus(self: Rep[OptimalString], o: Rep[Any]) extends FunctionDef[OptimalString](Some(self), "+", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringString(self: Rep[OptimalString]) extends FunctionDef[String](Some(self), "string", List()) {
    override def curriedConstructor = (copy _)
  }

  case class OptimalStringZip(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Array[Tuple2[Byte, Byte]]](Some(self), "zip", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringFoldLeft(self: Rep[OptimalString], c: Rep[Int], f: Rep[((Int, Byte) => Int)]) extends FunctionDef[Int](Some(self), "foldLeft", List(List(c), List(f))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalString_Field_Data(self: Rep[OptimalString]) extends FieldDef[Array[Byte]](self, "data") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class OptimalStringApplyObject(data: Rep[Array[Byte]]) extends FunctionDef[OptimalString](None, "OptimalString.apply", List(List(data))) {
    override def curriedConstructor = (copy _)
  }

  case class OptimalStringDefaultObject() extends FunctionDef[OptimalString](None, "OptimalString.default", List()) {
    override def curriedConstructor = (x: Any) => copy()
  }

  // method definitions
  def optimalStringNew(data: Rep[Array[Byte]]): Rep[OptimalString] = OptimalStringNew(data)
  def optimalStringEquals(self: Rep[OptimalString], o: Rep[Any]): Rep[Boolean] = OptimalStringEquals(self, o)
  def optimalStringApply(self: Rep[OptimalString], i: Rep[Int]): Rep[Byte] = OptimalStringApply(self, i)
  def optimalStringStartsWith(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalStringStartsWith(self, o)
  def optimalStringContainsSlice(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalStringContainsSlice(self, o)
  def optimalStringEndsWith(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalStringEndsWith(self, o)
  def optimalStringSlice(self: Rep[OptimalString], start: Rep[Int], end: Rep[Int]): Rep[OptimalString] = OptimalStringSlice(self, start, end)
  def optimalStringIndexOfSlice(self: Rep[OptimalString], o: Rep[OptimalString], i: Rep[Int]): Rep[Int] = OptimalStringIndexOfSlice(self, o, i)
  def optimalStringDiff(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Int] = OptimalStringDiff(self, o)
  def optimalStringCompare(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Int] = OptimalStringCompare(self, o)
  def optimalString$eq$eq$eq(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalString$eq$eq$eq(self, o)
  def optimalString$eq$bang$eq(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalString$eq$bang$eq(self, o)
  def optimalString$plus(self: Rep[OptimalString], o: Rep[Any]): Rep[OptimalString] = OptimalString$plus(self, o)
  def optimalStringString(self: Rep[OptimalString]): Rep[String] = OptimalStringString(self)
  def optimalStringZip(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Array[Tuple2[Byte, Byte]]] = OptimalStringZip(self, o)
  def optimalStringFoldLeft(self: Rep[OptimalString], c: Rep[Int], f: Rep[((Int, Byte) => Int)]): Rep[Int] = OptimalStringFoldLeft(self, c, f)
  def optimalString_Field_Data(self: Rep[OptimalString]): Rep[Array[Byte]] = OptimalString_Field_Data(self)
  def optimalStringApplyObject(data: Rep[Array[Byte]]): Rep[OptimalString] = OptimalStringApplyObject(data)
  def optimalStringDefaultObject(): Rep[OptimalString] = OptimalStringDefaultObject()
  type OptimalString = ch.epfl.data.pardis.shallow.OptimalString
  case object OptimalStringType extends TypeRep[OptimalString] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = OptimalStringType
    val name = "OptimalString"
    val typeArguments = Nil

    val typeTag = scala.reflect.runtime.universe.typeTag[OptimalString]
  }
  implicit val typeOptimalString = OptimalStringType
}
trait OptimalStringImplicits { this: OptimalStringComponent =>
  // Add implicit conversions here!
}
trait OptimalStringImplementations { self: DeepDSL =>

}
trait OptimalStringComponent extends OptimalStringOps with OptimalStringImplicits { self: DeepDSL => }

trait LoaderOps extends Base { this: DeepDSL =>
  implicit class LoaderRep(self: Rep[Loader]) {

  }
  object Loader {
    def loadString(size: Rep[Int], s: Rep[K2DBScanner]): Rep[OptimalString] = loaderLoadStringObject(size, s)
    def fileLineCount(file: Rep[String]): Rep[Int] = loaderFileLineCountObject(file)
    def loadRegion(): Rep[Array[REGIONRecord]] = loaderLoadRegionObject()
    def loadPartsupp(): Rep[Array[PARTSUPPRecord]] = loaderLoadPartsuppObject()
    def loadPart(): Rep[Array[PARTRecord]] = loaderLoadPartObject()
    def loadNation(): Rep[Array[NATIONRecord]] = loaderLoadNationObject()
    def loadSupplier(): Rep[Array[SUPPLIERRecord]] = loaderLoadSupplierObject()
    def loadLineitem(): Rep[Array[LINEITEMRecord]] = loaderLoadLineitemObject()
    def loadOrders(): Rep[Array[ORDERSRecord]] = loaderLoadOrdersObject()
    def loadCustomer(): Rep[Array[CUSTOMERRecord]] = loaderLoadCustomerObject()
  }
  // constructors

  // case classes
  case class LoaderLoadStringObject(size: Rep[Int], s: Rep[K2DBScanner]) extends FunctionDef[OptimalString](None, "Loader.loadString", List(List(size, s))) {
    override def curriedConstructor = (copy _).curried
  }

  case class LoaderFileLineCountObject(file: Rep[String]) extends FunctionDef[Int](None, "Loader.fileLineCount", List(List(file))) {
    override def curriedConstructor = (copy _)
  }

  case class LoaderLoadRegionObject() extends FunctionDef[Array[REGIONRecord]](None, "Loader.loadRegion", List(List())) {
    override def curriedConstructor = (x: Any) => copy()
  }

  case class LoaderLoadPartsuppObject() extends FunctionDef[Array[PARTSUPPRecord]](None, "Loader.loadPartsupp", List(List())) {
    override def curriedConstructor = (x: Any) => copy()
  }

  case class LoaderLoadPartObject() extends FunctionDef[Array[PARTRecord]](None, "Loader.loadPart", List(List())) {
    override def curriedConstructor = (x: Any) => copy()
  }

  case class LoaderLoadNationObject() extends FunctionDef[Array[NATIONRecord]](None, "Loader.loadNation", List(List())) {
    override def curriedConstructor = (x: Any) => copy()
  }

  case class LoaderLoadSupplierObject() extends FunctionDef[Array[SUPPLIERRecord]](None, "Loader.loadSupplier", List(List())) {
    override def curriedConstructor = (x: Any) => copy()
  }

  case class LoaderLoadLineitemObject() extends FunctionDef[Array[LINEITEMRecord]](None, "Loader.loadLineitem", List(List())) {
    override def curriedConstructor = (x: Any) => copy()
  }

  case class LoaderLoadOrdersObject() extends FunctionDef[Array[ORDERSRecord]](None, "Loader.loadOrders", List(List())) {
    override def curriedConstructor = (x: Any) => copy()
  }

  case class LoaderLoadCustomerObject() extends FunctionDef[Array[CUSTOMERRecord]](None, "Loader.loadCustomer", List(List())) {
    override def curriedConstructor = (x: Any) => copy()
  }

  // method definitions
  def loaderLoadStringObject(size: Rep[Int], s: Rep[K2DBScanner]): Rep[OptimalString] = LoaderLoadStringObject(size, s)
  def loaderFileLineCountObject(file: Rep[String]): Rep[Int] = LoaderFileLineCountObject(file)
  def loaderLoadRegionObject(): Rep[Array[REGIONRecord]] = LoaderLoadRegionObject()
  def loaderLoadPartsuppObject(): Rep[Array[PARTSUPPRecord]] = LoaderLoadPartsuppObject()
  def loaderLoadPartObject(): Rep[Array[PARTRecord]] = LoaderLoadPartObject()
  def loaderLoadNationObject(): Rep[Array[NATIONRecord]] = LoaderLoadNationObject()
  def loaderLoadSupplierObject(): Rep[Array[SUPPLIERRecord]] = LoaderLoadSupplierObject()
  def loaderLoadLineitemObject(): Rep[Array[LINEITEMRecord]] = LoaderLoadLineitemObject()
  def loaderLoadOrdersObject(): Rep[Array[ORDERSRecord]] = LoaderLoadOrdersObject()
  def loaderLoadCustomerObject(): Rep[Array[CUSTOMERRecord]] = LoaderLoadCustomerObject()
  type Loader = ch.epfl.data.legobase.storagemanager.Loader
  case object LoaderType extends TypeRep[Loader] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = LoaderType
    val name = "Loader"
    val typeArguments = Nil

    val typeTag = scala.reflect.runtime.universe.typeTag[Loader]
  }
  implicit val typeLoader = LoaderType
}
trait LoaderImplicits { this: LoaderComponent =>
  // Add implicit conversions here!
}
trait LoaderImplementations { self: DeepDSL =>

}
trait LoaderComponent extends LoaderOps with LoaderImplicits { self: DeepDSL => }

trait K2DBScannerOps extends Base { this: DeepDSL =>
  implicit class K2DBScannerRep(self: Rep[K2DBScanner]) {
    def next_int(): Rep[Int] = k2DBScannerNext_int(self)
    def next_double(): Rep[Double] = k2DBScannerNext_double(self)
    def next_char(): Rep[Char] = k2DBScannerNext_char(self)
    def next(buf: Rep[Array[Byte]])(implicit overload1: Overloaded1): Rep[Int] = k2DBScannerNext1(self, buf)
    def next(buf: Rep[Array[Byte]], offset: Rep[Int])(implicit overload2: Overloaded2): Rep[Int] = k2DBScannerNext2(self, buf, offset)
    def next_date: Rep[Long] = k2DBScannerNext_date(self)
    def hasNext(): Rep[Boolean] = k2DBScannerHasNext(self)
    def delimiter_=(x$1: Rep[Char]): Rep[Unit] = k2DBScanner_Field_Delimiter_$eq(self, x$1)
    def delimiter: Rep[Char] = k2DBScanner_Field_Delimiter(self)
    def intDigits_=(x$1: Rep[Int]): Rep[Unit] = k2DBScanner_Field_IntDigits_$eq(self, x$1)
    def intDigits: Rep[Int] = k2DBScanner_Field_IntDigits(self)
    def byteRead_=(x$1: Rep[Int]): Rep[Unit] = k2DBScanner_Field_ByteRead_$eq(self, x$1)
    def byteRead: Rep[Int] = k2DBScanner_Field_ByteRead(self)
    def filename: Rep[String] = k2DBScanner_Field_Filename(self)
  }
  object K2DBScanner {

  }
  // constructors
  def __newK2DBScanner(filename: Rep[String]): Rep[K2DBScanner] = k2DBScannerNew(filename)
  // case classes
  case class K2DBScannerNew(filename: Rep[String]) extends ConstructorDef[K2DBScanner](List(), "K2DBScanner", List(List(filename))) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_int(self: Rep[K2DBScanner]) extends FunctionDef[Int](Some(self), "next_int", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_double(self: Rep[K2DBScanner]) extends FunctionDef[Double](Some(self), "next_double", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_char(self: Rep[K2DBScanner]) extends FunctionDef[Char](Some(self), "next_char", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext1(self: Rep[K2DBScanner], buf: Rep[Array[Byte]]) extends FunctionDef[Int](Some(self), "next", List(List(buf))) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScannerNext2(self: Rep[K2DBScanner], buf: Rep[Array[Byte]], offset: Rep[Int]) extends FunctionDef[Int](Some(self), "next", List(List(buf, offset))) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScannerNext_date(self: Rep[K2DBScanner]) extends FunctionDef[Long](Some(self), "next_date", List()) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerHasNext(self: Rep[K2DBScanner]) extends FunctionDef[Boolean](Some(self), "hasNext", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_Delimiter_$eq(self: Rep[K2DBScanner], x$1: Rep[Char]) extends FieldSetter[Char](self, "delimiter", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_Delimiter(self: Rep[K2DBScanner]) extends FieldGetter[Char](self, "delimiter") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_IntDigits_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]) extends FieldSetter[Int](self, "intDigits", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_IntDigits(self: Rep[K2DBScanner]) extends FieldGetter[Int](self, "intDigits") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_ByteRead_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]) extends FieldSetter[Int](self, "byteRead", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_ByteRead(self: Rep[K2DBScanner]) extends FieldGetter[Int](self, "byteRead") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_Filename(self: Rep[K2DBScanner]) extends FieldDef[String](self, "filename") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def k2DBScannerNew(filename: Rep[String]): Rep[K2DBScanner] = K2DBScannerNew(filename)
  def k2DBScannerNext_int(self: Rep[K2DBScanner]): Rep[Int] = K2DBScannerNext_int(self)
  def k2DBScannerNext_double(self: Rep[K2DBScanner]): Rep[Double] = K2DBScannerNext_double(self)
  def k2DBScannerNext_char(self: Rep[K2DBScanner]): Rep[Char] = K2DBScannerNext_char(self)
  def k2DBScannerNext1(self: Rep[K2DBScanner], buf: Rep[Array[Byte]]): Rep[Int] = K2DBScannerNext1(self, buf)
  def k2DBScannerNext2(self: Rep[K2DBScanner], buf: Rep[Array[Byte]], offset: Rep[Int]): Rep[Int] = K2DBScannerNext2(self, buf, offset)
  def k2DBScannerNext_date(self: Rep[K2DBScanner]): Rep[Long] = K2DBScannerNext_date(self)
  def k2DBScannerHasNext(self: Rep[K2DBScanner]): Rep[Boolean] = K2DBScannerHasNext(self)
  def k2DBScanner_Field_Delimiter_$eq(self: Rep[K2DBScanner], x$1: Rep[Char]): Rep[Unit] = K2DBScanner_Field_Delimiter_$eq(self, x$1)
  def k2DBScanner_Field_Delimiter(self: Rep[K2DBScanner]): Rep[Char] = K2DBScanner_Field_Delimiter(self)
  def k2DBScanner_Field_IntDigits_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]): Rep[Unit] = K2DBScanner_Field_IntDigits_$eq(self, x$1)
  def k2DBScanner_Field_IntDigits(self: Rep[K2DBScanner]): Rep[Int] = K2DBScanner_Field_IntDigits(self)
  def k2DBScanner_Field_ByteRead_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]): Rep[Unit] = K2DBScanner_Field_ByteRead_$eq(self, x$1)
  def k2DBScanner_Field_ByteRead(self: Rep[K2DBScanner]): Rep[Int] = K2DBScanner_Field_ByteRead(self)
  def k2DBScanner_Field_Filename(self: Rep[K2DBScanner]): Rep[String] = K2DBScanner_Field_Filename(self)
  type K2DBScanner = ch.epfl.data.legobase.storagemanager.K2DBScanner
  case object K2DBScannerType extends TypeRep[K2DBScanner] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = K2DBScannerType
    val name = "K2DBScanner"
    val typeArguments = Nil

    val typeTag = scala.reflect.runtime.universe.typeTag[K2DBScanner]
  }
  implicit val typeK2DBScanner = K2DBScannerType
}
trait K2DBScannerImplicits { this: K2DBScannerComponent =>
  // Add implicit conversions here!
}
trait K2DBScannerImplementations { self: DeepDSL =>

}
trait K2DBScannerComponent extends K2DBScannerOps with K2DBScannerImplicits { self: DeepDSL => }

trait WindowRecordOps extends Base { this: DeepDSL =>
  implicit class WindowRecordRep[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = windowRecordGetField[B, C](self, key)(typeB, typeC)
    def wnd: Rep[C] = windowRecord_Field_Wnd[B, C](self)(typeB, typeC)
    def key: Rep[B] = windowRecord_Field_Key[B, C](self)(typeB, typeC)
  }
  object WindowRecord {

  }
  // constructors
  def __newWindowRecord[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = windowRecordNew[B, C](key, wnd)(typeB, typeC)
  // case classes
  case class WindowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends ConstructorDef[WindowRecord[B, C]](List(typeB, typeC), "WindowRecord", List(List(key, wnd))) {
    override def curriedConstructor = (copy[B, C] _).curried
  }

  case class WindowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy[B, C] _).curried
  }

  case class WindowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[C](self, "wnd") {
    override def curriedConstructor = (copy[B, C] _)
    override def isPure = true

  }

  case class WindowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[B](self, "key") {
    override def curriedConstructor = (copy[B, C] _)
    override def isPure = true

  }

  // method definitions
  def windowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = WindowRecordNew[B, C](key, wnd)
  def windowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Option[Any]] = WindowRecordGetField[B, C](self, key)
  def windowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[C] = WindowRecord_Field_Wnd[B, C](self)
  def windowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[B] = WindowRecord_Field_Key[B, C](self)
  type WindowRecord[B, C] = ch.epfl.data.legobase.queryengine.WindowRecord[B, C]
  case class WindowRecordType[B, C](typeB: TypeRep[B], typeC: TypeRep[C]) extends TypeRep[WindowRecord[B, C]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = WindowRecordType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]])
    private implicit val tagB = typeB.typeTag
    private implicit val tagC = typeC.typeTag
    val name = s"WindowRecord[${typeB.name}, ${typeC.name}]"
    val typeArguments = List(typeB, typeC)
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[WindowRecord[B, C]]
  }
  implicit def typeWindowRecord[B: TypeRep, C: TypeRep] = WindowRecordType(implicitly[TypeRep[B]], implicitly[TypeRep[C]])
}
trait WindowRecordImplicits { this: WindowRecordComponent =>
  // Add implicit conversions here!
}
trait WindowRecordImplementations { self: DeepDSL =>

}
trait WindowRecordComponent extends WindowRecordOps with WindowRecordImplicits { self: DeepDSL => }

trait DeepDSL extends OperatorsComponent with AGGRecordComponent with WindowRecordComponent with CharacterComponent
  with DoubleComponent with IntComponent with LongComponent with ArrayComponent
  with GroupByClassComponent
  with Q3GRPRecordComponent
  with Q7GRPRecordComponent
  with Q9GRPRecordComponent
  with Q10GRPRecordComponent
  with Q16GRPRecord1Component
  with Q16GRPRecord2Component
  with Q18GRPRecordComponent
  with Q20GRPRecordComponent
  with GenericEngineComponent
  with LINEITEMRecordComponent
  with SUPPLIERRecordComponent
  with PARTSUPPRecordComponent
  with REGIONRecordComponent
  with NATIONRecordComponent
  with PARTRecordComponent
  with CUSTOMERRecordComponent
  with ORDERSRecordComponent
  with OptimalStringComponent
  with LoaderComponent
  with K2DBScannerComponent with IntegerComponent
  with BooleanComponent with HashMapComponent with SetComponent with TreeSetComponent
  with DefaultEntryComponent with ArrayBufferComponent with ManualLiftedLegoBase with QueryComponent

